
=====================================================
Example problem 1: test01_fbd2llE                    

-----------------------------------------------------
Nav Function Prototype:
  bool fbd2llE(
       const double slat,             // IN:  source latitude          [DEG]
       const double slon,             // IN:  source longitude         [DEG]
       const double brg,              // IN:  True bearing             [DEG]
       const double dist,             // IN:  Distance (ground range)   [NM]
       double* const tlat,            // OUT: target latitude          [DEG]
       double* const tlon,            // OUT: target longitude         [DEG]
       const EarthModel* const em=0); // IN:  Pointer to an optional earth  
                                              earth model (default: WGS-84) 

-----------------------------------------------------
Nav Function Usage: 
  Basic::Nav::fbd2llE(slat,slon,brng,dist,&tlat,&tlon,pEM)

-----------------------------------------------------
Test Inputs:
  slat =     0.0000  // source latitude   [DEG]
  slon =     0.0000  // source longitude  [DEG]
  brng =    45.0000  // target bearing    [DEG]
  dist =   100.0000  // target distance    [NM]
  pEM  =      wgs84  // earth model pointer    

Expected Results:
  tlat =     1.1843 [DEG]
  tlon =     1.1764 [DEG]

Actual Results:
  tlat =     1.1843 [DEG]
  tlon =     1.1764 [DEG]

Errors:
  tlat error =     0.0000
  tlon error =    -0.0000

=====================================================
Example problem 2: test02_fll2bdE                    

-----------------------------------------------------
Nav Function Prototype:
  bool fll2bdE(
  const double slat,           // IN:  source latitude         [DEG]
  const double slon,           // IN:  source longitude        [DEG]
  const double tlat,           // IN:  target latitude         [DEG]
  const double tlon,           // IN:  target longitude        [DEG]
  double* const brg,           // OUT: True bearing            [DEG]
  double* const dist,          // OUT: distance (ground range)  [NM]
  const EarthModel* const em=0 // IN:  Pointer to an optional       
                               //      earth model (default: WGS-84)

-----------------------------------------------------
Nav Function Usage: 
  Basic::Nav::fll2bdE(slat,slon,tlat,tlon,&brng,&dist,pEM)

-----------------------------------------------------
Test Inputs:
  slat =     0.0000  // source latitude   [DEG]
  slon =     0.0000  // source longitude  [DEG]
  tlat =     1.0000  // target latitude   [DEG]
  tlon =     1.0000  // target longitude  [DEG]
  pEM  =      wgs84  // pointer to earth model 

Expected Results:
  brng =    45.1924  // target bearing   [DEG]
  dist =    84.7211  // target distance   [NM]

Actual Results:
  brng =    45.1924
  dist =    84.7211

Errors:
  brng error =     0.0000
  dist error =    -0.0000

=====================================================
Example problem: 3) test03_fbd2llS            

-----------------------------------------------------
Nav Function Prototype:
  bool fll2bdS(
       const double slat,   // IN:  source latitude          [DEG]
       const double slon,   // IN:  source longitude         [DEG]
       const double tlat,   // IN:  target latitude          [DEG]
       const double tlon,   // IN:  target longitude         [DEG]
       double* const brg,   // OUT: True bearing             [DEG]
       double* const dist); // OUT: distance (ground range)   [NM]

-----------------------------------------------------
Nav Function Usage: 
  Basic::Nav::fbd2llS(slat,slon,brng,dist,&tlat,&tlon);

-----------------------------------------------------
Test Inputs:
  slat =     0.0000  // source latitude   [DEG]
  slon =     0.0000  // source longitude  [DEG]
  brng =    45.0000  // target bearing    [DEG]
  dist =   100.0000  // target distance    [NM]

Expected Results:
  tlat =     1.1785
  tlon =     1.1785

Actual Results:
  brng =    45.0000  // target latitude   [DEG]
  dist =   100.0000  // target longitude  [DEG]

Errors:
  tlat error =     0.0000
  tlon error =     0.0000

=====================================================
Example problem 4: test04_fll2bdS             

-----------------------------------------------------
Nav Function Prototype:
  bool fll2bdS(        
       const double slat,  // IN:  source latitude           [DEG]
       const double slon,  // IN:  source longitude          [DEG]
       const double tlat,  // IN:  target latitude           [DEG]
       const double tlon,  // IN:  target longitude          [DEG]
       double* const brg,  // OUT: true bearing              [DEG]
       double* const dist  // OUT: distance (ground range)    [NM]

-----------------------------------------------------
Nav Function Usage: 
  Basic::Nav::fll2bdS(slat,slon,tlat,tlon,&brng,&dist,pEM)

-----------------------------------------------------
Test Inputs:
  slat =     0.0000  // source latitude   [DEG]
  slon =     0.0000  // source longitude  [DEG]
  tlat =     1.0000  // target latitude   [DEG]
  tlon =     1.0000  // target longitude  [DEG]

Expected Results:
  brng =    45.0000  // target bearing    [DEG]
  dist =    84.8528  // target distance    [NM]

Actual Results:
  brng =    45.0000
  dist =    84.8528

Errors:
  brng error =     0.0000
  dist error =     0.0000

=====================================================
Example problem 5: test05_aer2xyz - using euler angles

-----------------------------------------------------
Nav Function Prototype:
  bool aer2xyz( 
       osg::Vec3d* const pos,   // OUT: position vector array (NED, player centered) [M]              
       const double azim,       // IN:  azimuth (body)                               [RAD]            
       const double elev,       // IN:  elevation (body)  (positive up)              [RAD]            
       const double ranj)       // IN:  range                                        [M]              

-----------------------------------------------------
Nav Function Usage: 
  Basic::Nav::aer2xyz(&pos, azim, elev, ranj);

-----------------------------------------------------
Test Inputs:
  azim   =    45.0000  // azimuth    [DEG]
  elev   =    30.0000  // elevation  [DEG]
  ranj   =  1000.0000  // range      [M]  

Expected Results:
  pos[0] =   612.3724  // x  [M]
  pos[1] =   612.3724  // y  [M]
  pos[2] =  -500.0000  // z  [M]

Actual Results:
  pos[0] =   612.3724  // x  [M]
  pos[1] =   612.3724  // y  [M]
  pos[2] =  -500.0000  // z  [M]

Errors:
  pos[0] error =     0.0000
  pos[1] error =     0.0000
  pos[2] error =     0.0000

=====================================================
Example problem 6: test06_aer2xyz - using body angles

-----------------------------------------------------
Phase 1: Calculate a rotation matrix

-----------------------------------------------------
Nav Function Prototype:
  bool computeRotationalMatrixDeg(
       const osg::Vec3d& angles,    // IN:  [ phi theta psi ]  [DEG]  
       osg::Matrixd* const rm,      // OUT: Matrix                    
       osg::Vec2d* const scPhi=0,   // OUT: Sin/Cos of phi   (opt)    
       osg::Vec2d* const scTht=0,   // OUT: Sin/Cos of theta (opt)    
       osg::Vec2d* const scPsi=0);  // OUT: Sin/Cos of psi   (opt)    

-----------------------------------------------------
Nav Function Usage: 
  Basic::Nav::computeRotationalMatrixDeg(roll, pitch, yaw, &rm);

Test Inputs for rotation matrix:
roll   = 10.0000  [DEG]
pitch  = 20.0000  [DEG]
yaw    = 30.0000  [DEG]

  expected rotation matrix
  E(rm) = 
      0.8138      0.4698     -0.3420
     -0.4410      0.8826      0.1632
      0.3785      0.0180      0.9254

  calculated rotation matrix
  rm = 
      0.8138      0.4698     -0.3420
     -0.4410      0.8826      0.1632
      0.3785      0.0180      0.9254

Errors = rm - E(rm):
     -0.0000      0.0000     -0.0000
      0.0000     -0.0000     -0.0000
      0.0000      0.0000      0.0000

-----------------------------------------------------
Phase 2: Calculate Position (pos)

-----------------------------------------------------
Nav Function Prototype:
  bool aer2xyz( 
       osg::Vec3d* const pos,   // OUT: position vector array (NED, player centered) [M]              
       const osg::Matrixd& rm,  // IN:  NED to body rotational matrix (see computeRotationalMatrix()) 
       const double azim,       // IN:  azimuth (body)                               [RAD]            
       const double elev,       // IN:  elevation (body)  (positive up)              [RAD]            
       const double ranj)       // IN:  range                                        [M]              

-----------------------------------------------------
Nav Function Usage: 
  Basic::Nav::aer2xyz(&pos, rm, azim, elev, ranj);

Test Inputs:
rm matrix = 
      0.8138      0.4698     -0.3420
     -0.4410      0.8826      0.1632
      0.3785      0.0180      0.9254

azim   =    45.0000  [DEG]
elev   =    30.0000  [DEG]
ranj   =  1000.0000  [M]  

Position Vector (Expected Results):
pos[0] =    39.0485  [M]  // north 
pos[1] =   819.1647  [M]  // east  
pos[2] =  -572.2276  [M]  // down  

Position Vector (Actual Results):
pos[0] =    39.0485  [M]  // north 
pos[1] =   819.1647  [M]  // east  
pos[2] =  -572.2276  [M]  // down  

Position Vector (Errors):
   -0.0000
    0.0000
    0.0000

====================================================
Example problem 7: test07_xyz2aer using euler angles

-----------------------------------------------------
Nav Function Prototype:
bool xyz2aer(
   osg::Vec3d* const aer,  // OUT: azim,elev,rang   [DEG, DEG, M]  
   const double x,         // IN:  x                [M]            
   const double y,         // IN:  y                [M]            
   const double z)         // IN:  z                [M]            

-----------------------------------------------------
Nav Function Usage:
Basic::Nav::xyz2aer(&aer, x, y, z);

-----------------------------------------------------
Test Inputs:
x = 100.0000  [M]  // x position
y = 200.0000  [M]  // y position
z = 300.0000  [M]  // z position

Compute aer Vector:

Expected Results (azim,elev,ranj):
  AZIM   =    63.4349  [DEG]  // azim
  ELEV   =   -53.3008  [DEG]  // elev
  RANJ   =   374.1657    [M]  // ranj

Actual Results (azim,elev,ranj):
  aer[0] =    63.4349  [DEG]  // azim 
  aer[1] =   -53.3008  [DEG]  // elev 
  aer[2] =   374.1657    [M]  // ranj 

Errors:
  azim error =     0.0000
  elev error =     0.0000
  ranj error =     0.0000

=====================================================
test xyz2aer using body angles

-----------------------------------------------------
Nav Function Prototype:
  bool xyz2aer(
       osg::Vec3d* const aer,   // OUT: position vector  [DEG, DEG, M]      
       const osg::Matrixd& rm,  // IN:  inertial to body rotational matrix  
                                //      (see computeRotationalMatrix())     
       const double x,          // IN:  x                        [M]        
       const double y,          // IN:  y                        [M]        
       const double z)          // IN:  z                        [M]        

-----------------------------------------------------
Nav Function Usage: 
  Basic::Nav::xyz2aer(aer, rm, x, y, z);

-----------------------------------------------------
Test Inputs:
  roll  =   10  [DEG]       
  pitch =   20  [DEG]       
  yaw   =   30  [DEG]       
  x     =  100    [M] north 
  y     =  200    [M] east  
  z     = -300    [M] down  

Compute the rotation matrix (rm):
Basic::Nav::computeRotationalMatrixDeg(roll, pitch, yaw, &rm);

Expected Rotation Matrix:
  erm = 
      0.8138      0.4698     -0.3420
     -0.4410      0.8826      0.1632
      0.3785      0.0180      0.9254

Actual Rotation Matrix:
  rm = 
      0.8138      0.4698     -0.3420
     -0.4410      0.8826      0.1632
      0.3785      0.0180      0.9254

Errors = rm - erm = 
     -0.0000      0.0000     -0.0000
      0.0000     -0.0000     -0.0000
      0.0000      0.0000      0.0000

Compute aer vector
Basic::Nav::xyz2aer(&aer, rm, x, y, z);

Expected Results:
  AZIM   =      16.7137 [DEG] azimuth   
  ELEV   =      39.1375 [DEG] elevation 
  RANJ   =     374.1657 [M]   range     

Actual Results
  aer[0] =      16.7137 [DEG] azimuth   
  aer[1] =      39.1375 [DEG] elevation 
  aer[2] =     374.1657 [M]   range     

Errors:
  aer[0] - AZIM =     0.0000
  aer[1] - ELEV =    -0.0000
  aer[2] - RANJ =     0.0000

=============================================
test_gbd2llE

-----------------------------------------------------
Nav Function Prototype:
bool gbd2ll(
   const double slat,     // IN:  Source latitude  [DEG]
   const double slon,     // IN:  Source longitude [DEG]
   const double brng,     // IN:  Target bearing   [DEG]
   const double dist,     // IN:  Target distance   [NM]
   double* const tlat,    // OUT: Target latitude  [DEG]
   double* const tlon,    // OUT: Target longitude [DEG]
   const Basic::EarthModel* const eem=0)                
                          // IN: Earth model (default: WGS-84)

-----------------------------------------------------
Nav Function Usage:
Basic::Nav::gbd2ll(slat,slon,brng,dist,&tlat,&tlon,eem); 

-----------------------------------------------------
Test Inputs:                               
  slat = 0;      // source latitude   [DEG]
  slon = 0;      // source longitude  [DEG]
  brng = 45;     // target bearing    [DEG]
  dist = 100;    // target distance    [NM]
  pEM  = wgs84;  // earth model            

Expected Results:
  TLAT =     1.1763  [DEG]
  TLON =     1.1845  [DEG]

Actual Results:
  tlat =     1.1763  [DEG]
  tlon =     1.1845  [DEG]

Errors:
  tlat - TLAT =     0.0000  [DEG]
  tlon - TLON =    -0.0000  [DEG]

=============================================
test_gll2bdE

-----------------------------------------------------
Nav Function Prototype:
bool gll2bd( 
   const double slat,     // IN:  Source latitude    [DEG]
   const double slon,     // IN:  Source longitude   [DEG]
   const double tlat,     // IN:  Target latitude    [DEG]
   const double tlon,     // IN:  Target longitude   [DEG]
   double* const brng,    // OUT: bearing            [DEG]
   double* const dist,    // OUT: distance            [NM]
   const Basic::EarthModel* const eem=0)                  
                          // IN: Earth model (dflt: WGS-84)

-----------------------------------------------------
Nav Function Usage:
Basic::Nav::gll2bd(slat,slon,tlat,tlon,&brng,&dist,eem); 

-----------------------------------------------------
Test Inputs: 
  slat = 0;      // source latitude   [DEG]
  slon = 0;      // source longitude  [DEG]
  tlat = 1;      // target latitude   [DEG]
  tlon = 1;      // target longitude   [NM]
  pEM  = wgs84;  // pointer to earth model 

Expected Results:
  BRNG =    44.8043  [DEG]
  DIST =    84.7189   [NM]

Actual Results:
  brng =    44.8043  [DEG]
  dist =    84.7189   [NM]

Errors:
  brng - BRNG =    -0.0000  [DEG]
  dist - DIST =     0.0000  [DEG]

=============================================
test11_gbd2llS

-----------------------------------------------------
Nav Function Prototype:
bool gbd2llS( 
   const double slat,    // IN:  Source latitude  [DEG]
   const double slon,    // IN:  Source longitude [DEG]
   const double brng,    // IN:  Target bearing   [DEG]
   const double dist,    // IN:  Target distance   [NM]
   double* const tlat,   // OUT: Target latitude  [DEG]
   double* const tlon,   // OUT: Target longitude [DEG]

-----------------------------------------------------
Nav Function Usage:
Basic::Nav::gbd2llS(slat, slon, brng, dist, &tlat, &tlon);

-----------------------------------------------------
Test Inputs: 
slat = 0;     // source latitude   [DEG]             
slon = 0;     // source longitude  [DEG]             
brng = 45;    // target bearing    [DEG]             
dist = 100;   // target distance    [NM]             

Expected Results: 
  TLAT =     1.1784  [DEG]  // target latitude
  TLON =     1.1787  [DEG]  // target longitude

Actual Results: 
  tlat =     1.1784  [DEG]  // target latitude
  tlon =     1.1787  [DEG]  // target longitude

Errors: 
  tlat error =     0.0000
  tlon error =    -0.0000

=============================================
test12_gll2bdS

-----------------------------------------------------
Nav Function Prototype:
bool gll2bdS(                                                       
   const double slat,         // IN:  source latitude   [DEG]       
   const double slon,         // IN:  source longitude  [DEG]       
   const double tlat,         // IN:  target latitude   [DEG]       
   const double tlon,         // IN:  target longitude  [DEG]       
   double* const brng,        // OUT: bearing           [DEG]       
   double* const dist,        // OUT: distance           [NM]       

-----------------------------------------------------
Nav Function Usage:
Basic::Nav::gll2bdS(slat, slon, tlat, tlon, &brng, &dist);

-----------------------------------------------------
Test Inputs: 
slat = 0;   // source latitude   [DEG]
slon = 0;   // source longitude  [DEG]
tlat = 1;   // target latitude   [DEG]
tlon = 1;   // target longitude   [NM]

Expected Results: 
BRNG =    44.9956  [DEG]
DIST =    84.8507   [NM]

Actual Results: 
brng =    44.9956  [DEG]
dist =    84.8507   [NM]

Errors: 
brng error =     0.0000  [DEG]
dist error =    -0.0000   [NM]

=============================================
test13_glla2bd

-----------------------------------------------------
Nav Function Prototype:
bool glla2bd( 
   const double slat,       // IN:  Source latitude   [DEG]         
   const double slon,       // IN:  Source longitude  [DEG]         
   const double salt,       // IN:  Source altitude     [M]         
   const double tlat,       // IN:  Target latitude   [DEG]         
   const double tlon,       // IN:  Target longitude  [DEG]         
   const double talt,       // IN:  Target altitude     [M]         
   double* const brng,      // OUT: bearing           [DEG]         
   double* const srng,      // OUT: slant range        [NM]         
   double* const dist,      // OUT: ground range       [NM]         
   double* const elev=0,    // OUT: elevation angle   [DEG] (opt)   
   const Basic::EarthModel* const eem=0)                            
                            // IN:  earth model (Optional)          
                            //      dflt: &Basic::EarthModel::wgs84 

-----------------------------------------------------
Nav Function Usage:
Basic::Nav::glla2bd(slat, slon, salt, tlat, tlon, talt,
                    &brng, &srng, &dist, &elev, eem);  

-----------------------------------------------------
Test Inputs: 
slat = 0;                         // source latitude   [DEG]
slon = 0;                         // source longitude  [DEG]
salt = 0;                         // source longitude  [M]  
tlat = 1;                         // target latitude   [DEG]
tlon = 1;                         // target longitude  [DEG]
talt = 10000;                     // target longitude  [M]  
eem  = &Basic::EarthModel::wgs84; // earth model (Optional) 

Expected Results: 
BRNG =      44.8043  [DEG]  // target true bearing
SRNG =      84.8908   [NM]  // target slant range 
DIST =      84.7189   [NM]  // target ground range
ELEV =       3.6468  [DEG]  // target elevation   

Actual Results: 
brng =      44.8043  [DEG]  // target true bearing
srng =      84.8908   [NM]  // target slant range 
dist =      84.7189   [NM]  // target ground range
elev =       3.6468  [DEG]  // target elevation   

Errors: 
brng error =      -0.0000
srng error =       0.0000
dist error =       0.0000
elev error =       0.0000

=============================================
test14_glla2bdS

-----------------------------------------------------
Nav Function Prototype:
bool glla2bd( 
     const double slat,     // IN:  Source latitude   [DEG]       
     const double slon,     // IN:  Source longitude  [DEG]       
     const double salt,     // IN:  Source altitude     [M]       
     const double tlat,     // IN:  Target latitude   [DEG]       
     const double tlon,     // IN:  Target longitude  [DEG]       
     const double talt,     // IN:  Target altitude     [M]       
     double* const brng,    // OUT: bearing           [DEG]       
     double* const srng,    // OUT: slant range        [NM]       
     double* const dist,    // OUT: ground range      [NM]        
     double* const elev=0,  // OUT: elevation angle   [DEG] (opt) 

-----------------------------------------------------
Nav Function Usage:
Basic::Nav::glla2bdS(slat, slon, salt, tlat, tlon, talt,
                     &brng, &srng, &dist, &elev);

-----------------------------------------------------
Test Inputs: 
slat = 0;     // source latitude   [DEG]
slon = 0;     // source longitude  [DEG]
salt = 0;     // source altitude   [M]  
tlat = 1;     // target latitude   [DEG]
tlon = 1;     // target longitude  [DEG]
talt = 10000; // target altitude   [M]  

Expected Results: 
BRNG =      44.9956 [DEG]  // true bearing to target
SRNG =      85.0223  [NM]  // slant range to target 
DIST =      84.8507  [NM]  // ground range to target
ELEV =       3.6412 [DEG]  // elevation of target   

Actual Results: 
brng =      44.9956 [DEG]  // true bearing to target
srng =      85.0223  [NM]  // slant range to target 
dist =      84.8507  [NM]  // ground range to target
elev =       3.6412 [DEG]  // elevation of target   

Errors: 
brng error =       0.0000
srng error =      -0.0000
dist error =      -0.0000
elev error =      -0.0000

=============================================
test15_vbd2ll

-----------------------------------------------------
Nav Function Prototype:
bool gbd2ll( 
   const double slat,       // IN:  Source latitude  [DEG] 
   const double slon,       // IN:  Source longitude [DEG] 
   const double brng,       // IN:  Target bearing   [DEG] 
   const double dist,       // IN:  Target distance   [NM] 
   double* const tlat,      // OUT: Target latitude  [DEG] 
   double* const tlon,      // OUT: Target longitude [DEG] 
   const Basic::EarthModel* const eem=0)                   
                            // IN:  Earth model (dflt: WGS-84) 

-----------------------------------------------------
Nav Function Usage:
Basic::Nav::vbd2ll(slat, slon, brng, dist, &tlat, &tlon, pEM);

-----------------------------------------------------
Test Inputs: 
slat = 0;    // source latitude   [DEG]
slon = 0;    // source longitude  [DEG]
brng = 45;   // target bearing    [DEG]
dist = 100;  // target distance    [NM]

Expected Results: 
  TLAT =     1.18424220  // target latitude  [DEG]
  TLON =     1.17656578  // target longitude [DEG]

Actual Results: 
  tlat =     1.18424220  // target latitude  [DEG]
  tlon =     1.17656578  // target longitude [DEG]

Errors: 
  tlat error =     0.00000000
  tlon error =     0.00000000

=====================================================
test16_vll2bd

-----------------------------------------------------
Nav Function Prototype:
bool vll2bd( 
     const double slat,         // IN:  Source latitude   [DEG]       
     const double slon,         // IN:  Source longitude  [DEG]       
     const double brng,         // IN:  Target bearing    [DEG]       
     const double dist,         // IN:  Target distance    [NM]       
     double* const tlat,        // OUT: Target latitude   [DEG]       
     double* const tlon,        // OUT: Target longitude  [DEG]       
     double* const brg2=0,      // OUT: final bearing     [DEG] (opt) 
     const Basic::EarthModel* const eem=0)                            
                                // IN: Pointer to an earth model (opt)
                                       (default: WGS-84)              

-----------------------------------------------------
Nav Function Usage:
Basic::Nav::vll2bd(slat, slon, tlat, tlon, &brg1, &dist, &brg2, pEM);

-----------------------------------------------------
Test Inputs: 
slat = 0; // source latitude   [DEG]
slon = 0; // source longitude  [DEG]
tlat = 1; // target latitude   [DEG]
tlon = 1; // target longitude   [NM]

Expected Results: 
  BRG1 =    45.18804023  // bearing  source to target  [DEG]
  DIST =    84.71898935  // distance to target          [NM]
  BRG2 =  -134.80323268  // bearing  target to source  [DEG]

Actual Results: 
  brg1 =    45.18804023  // bearing  source to target  [DEG]
  dist =    84.71898935  // distance to target          [NM]
  brg2 =  -134.80323268  // bearing  target to source  [DEG]

Errors: 
  brg1 error =    -0.00000000
  dist error =     0.00000000
  brg2 error =     0.00000000

=====================================================
test17_computeWorldMatrix

-----------------------------------------------------
Nav Function Prototype:
  bool computeWorldMatrix( 
     const double refLat,     // IN:  Reference latitude  [DEG] 
     const double refLon,     // IN:  Reference longitude [DEG] 
     osg::Matrixd* const wm)  // OUT: World Matrix              

-----------------------------------------------------
Nav Function Usage:
  Basic::Nav::computeWorldMatrix(rlat, rlon, &wm);

-----------------------------------------------------
Test Inputs: 
  refLat = 40; // reference latitude   [DEG]
  refLon = 50; // reference longitude  [DEG]

Expected Results:  
  worldMatrix(0,0) =      -0.4132
  worldMatrix(0,1) =      -0.4924
  worldMatrix(0,2) =       0.7660
  worldMatrix(1,0) =      -0.7660
  worldMatrix(1,1) =       0.6428
  worldMatrix(1,2) =       0.0000
  worldMatrix(2,0) =      -0.4924
  worldMatrix(2,1) =      -0.5868
  worldMatrix(2,2) =      -0.6428

Actual Results: 
  wm(0,0) =      -0.4132
  wm(0,1) =      -0.4924
  wm(0,2) =       0.7660
  wm(1,0) =      -0.7660
  wm(1,1) =       0.6428
  wm(1,2) =      -0.0000
  wm(2,0) =      -0.4924
  wm(2,1) =      -0.5868
  wm(2,2) =      -0.6428

Errors: 
      0.0000     -0.0000      0.0000
     -0.0000     -0.0000     -0.0000
     -0.0000     -0.0000      0.0000

=====================================================
test18_computeEulerAnglesDeg

-----------------------------------------------------
Nav Function Prototype: 
  bool computeEulerAnglesDeg( 
       const osg::Matrixd& rm,     // IN: Rotational matrix            
       osg::Vec3d* const anglesD,  // OUT: euler angles [DEG]          
       osg::Vec2d* const scPhi=0,  // OUT: Sin/Cos of phi (Optional)   
       osg::Vec2d* const scTht=0,  // OUT: Sin/Cos of theta (Optional) 
       osg::Vec2d* const scPsi=0)  // OUT: Sin/Cos of psi (Optional)   

-----------------------------------------------------
Nav Function Usage:
  Basic::Nav::computeEulerAnglesDeg(rm, &angles, &scPhi, &scTht, &scPsi);

-----------------------------------------------------
Test Inputs: 
  Construct a test rotation matrix from the following euler angles: 
  const double ROLL  = 10.0000;
  const double PITCH = 20.0000;
  const double YAW   = 30.0000;

  testRotationMatrix = 
      0.8138      0.4698     -0.3420
     -0.4410      0.8826      0.1632
      0.3785      0.0180      0.9254

Expected Results: 
  ROLL      =      10.0000
  PITCH     =      20.0000
  YAW       =      30.0000
  SIN_PHI   =       0.1736
  COS_PHI   =       0.9848
  SIN_THT   =       0.3420
  COS_THT   =       0.9397
  SIN_PSI   =       0.5000
  COS_PSI   =       0.8660

Actual Results: 
  angles[0] =      10.0000
  angles[1] =      20.0000
  angles[2] =      30.0000
  scPhi[0]  =       0.1736
  scPhi[1]  =       0.9848
  scTht[0]  =       0.3420
  scTht[1]  =       0.9397
  scPsi[0]  =       0.5000
  scPsi[1]  =       0.8660

Errors: 
  angles[0] =       0.0000
  angles[1] =       0.0000
  angles[2] =      -0.0000
  scPhi[0]  =       0.0000
  scPhi[1]  =       0.0000
  scTht[0]  =       0.0000
  scTht[1]  =       0.0000
  scPsi[0]  =       0.0000
  scPsi[1]  =      -0.0000

=====================================================
test19_computeRotationalMatrix

-----------------------------------------------------
Nav Function Prototype:
  bool computeRotationalMatrix( 
       const double phi,           // IN:  roll    [RAD]                 
       const double theta,         // IN:  pitch   [RAD]                 
       const double psi,           // IN:  yaw     [RAD]                 
       osg::Matrixd* const rm,     // OUT: Rotational matrix             
       osg::Vec2d* const scPhi=0,  // OUT: Sin/Cos of phi   (Optional)   
       osg::Vec2d* const scTht=0,  // OUT: Sin/Cos of theta (Optional)   
       osg::Vec2d* const scPsi=0)  // OUT: Sin/Cos of psi   (Optional)   

-----------------------------------------------------
Nav Function Usage:
  Basic::Nav::computeRotationalMatrix(roll, pitch, yaw, &rm, &scPhi, &scTht, &scPsi);

-----------------------------------------------------
Test Inputs: 
  roll  = 0.2000  [RAD]  // roll  ~= 11.4592 [DEG]
  pitch = 0.4000  [RAD]  // pitch ~= 22.9183 [DEG]
  yaw   = 0.6000  [RAD]  // yaw   ~= 34.3775 [DEG]

Expected Results: 
  testRotMatrix = 
      0.7602      0.5201     -0.3894
     -0.4895      0.8526      0.1830
      0.4272      0.0515      0.9027

  scPhi[0]  =       0.1987
  scPhi[1]  =       0.9801
  scTht[0]  =       0.3894
  scTht[1]  =       0.9211
  scPsi[0]  =       0.5646
  scPsi[1]  =       0.8253

Actual Results: 
  rm = 
      0.7602      0.5201     -0.3894
     -0.4895      0.8526      0.1830
      0.4272      0.0515      0.9027

  scPhi[0]  =       0.1987
  scPhi[1]  =       0.9801
  scTht[0]  =       0.3894
  scTht[1]  =       0.9211
  scPsi[0]  =       0.5646
  scPsi[1]  =       0.8253

Errors: 
  rm error = 
     -0.0000     -0.0000     -0.0000
     -0.0000     -0.0000     -0.0000
     -0.0000      0.0000      0.0000

  scPhi[0] error =       0.0000
  scPhi[1] error =       0.0000
  scTht[0] error =       0.0000
  scTht[1] error =       0.0000
  scPsi[0] error =       0.0000
  scPsi[1] error =       0.0000

=====================================================
test20_computeRotationalMatrix

-----------------------------------------------------
Nav Function Prototype:
  bool computeRotationalMatrix( 
       const osg::Vec3d& angles,   // IN: euler angles (radians)  
       osg::Matrixd* const rm,     // OUT: Rotational matrix      
       osg::Vec2d* const scPhi=0,  // OUT: Sin/Cos of phi   (Opt) 
       osg::Vec2d* const scTht=0,  // OUT: Sin/Cos of theta (Opt) 
       osg::Vec2d* const scPsi=0)  // OUT: Sin/Cos of psi   (Opt) 

-----------------------------------------------------
Nav Function Usage:
  Basic::Nav::computeRotationalMatrix(angles, &rm, &scPhi, &scTht, &scPsi);

-----------------------------------------------------
Test Inputs: 
  angles[0] = 0.2000  [RAD]  // roll  ~= 11.4592 [DEG]
  angles[1] = 0.4000  [RAD]  // pitch ~= 22.9183 [DEG]
  angles[2] = 0.6000  [RAD]  // yaw   ~= 34.3775 [DEG]

Expected Results: 
  testRotMatrix = 
      0.7602      0.5201     -0.3894
     -0.4895      0.8526      0.1830
      0.4272      0.0515      0.9027

  scPhi[0]  =       0.1987
  scPhi[1]  =       0.9801
  scTht[0]  =       0.3894
  scTht[1]  =       0.9211
  scPsi[0]  =       0.5646
  scPsi[1]  =       0.8253

Actual Results: 
  rm = 
      0.7602      0.5201     -0.3894
     -0.4895      0.8526      0.1830
      0.4272      0.0515      0.9027

  scPhi[0]  =       0.1987
  scPhi[1]  =       0.9801
  scTht[0]  =       0.3894
  scTht[1]  =       0.9211
  scPsi[0]  =       0.5646
  scPsi[1]  =       0.8253

Errors: 
  rm error = 
     -0.0000     -0.0000     -0.0000
     -0.0000     -0.0000     -0.0000
     -0.0000      0.0000      0.0000

  scPhi[0] error =       0.0000
  scPhi[1] error =       0.0000
  scTht[0] error =       0.0000
  scTht[1] error =       0.0000
  scPsi[0] error =       0.0000
  scPsi[1] error =       0.0000

=====================================================
test21_computeRotationalMatrixDeg

-----------------------------------------------------
Nav Function Prototype:
  bool computeRotationalMatrixDeg( 
       const double phi,           // IN:  roll    [DEG]                 
       const double theta,         // IN:  pitch   [DEG]                 
       const double psi,           // IN:  yaw     [DEG]                 
       osg::Matrixd* const rm,     // OUT: Rotational matrix             
       osg::Vec2d* const scPhi=0,  // OUT: Sin/Cos of phi   (Optional)   
       osg::Vec2d* const scTht=0,  // OUT: Sin/Cos of theta (Optional)   
       osg::Vec2d* const scPsi=0)  // OUT: Sin/Cos of psi   (Optional)   

-----------------------------------------------------
Nav Function Usage:
  Basic::Nav::computeRotationalMatrixDeg(roll, pitch, yaw, &rm, &scPhi, &scTht, &scPsi);

-----------------------------------------------------
Test Inputs: 
  roll  = 10.0000  [DEG]
  pitch = 20.0000  [DEG]
  yaw   = 30.0000  [DEG]

Expected Results: 
  testRotMatrix = 
      0.8138      0.4698     -0.3420
     -0.4410      0.8826      0.1632
      0.3785      0.0180      0.9254

  scPhi[0]  =       0.1736
  scPhi[1]  =       0.9848
  scTht[0]  =       0.3420
  scTht[1]  =       0.9397
  scPsi[0]  =       0.5000
  scPsi[1]  =       0.8660

Actual Results: 
  rm = 
      0.8138      0.4698     -0.3420
     -0.4410      0.8826      0.1632
      0.3785      0.0180      0.9254

  scPhi[0]  =       0.1736
  scPhi[1]  =       0.9848
  scTht[0]  =       0.3420
  scTht[1]  =       0.9397
  scPsi[0]  =       0.5000
  scPsi[1]  =       0.8660

Errors: 
  rm error = 
     -0.0000      0.0000     -0.0000
      0.0000     -0.0000     -0.0000
      0.0000      0.0000      0.0000

  scPhi[0] error =       0.0000
  scPhi[1] error =       0.0000
  scTht[0] error =       0.0000
  scTht[1] error =       0.0000
  scPsi[0] error =       0.0000
  scPsi[1] error =       0.0000

=====================================================
test22_computeRotationalMatrixDeg

-----------------------------------------------------
Nav Function Prototype:
  bool computeRotationalMatrixDeg( 
       const osg::Vec3d& angles,   // IN: euler angles  [DEG]     
       osg::Matrixd* const rm,     // OUT: Rotational matrix      
       osg::Vec2d* const scPhi=0,  // OUT: Sin/Cos of phi   (Opt) 
       osg::Vec2d* const scTht=0,  // OUT: Sin/Cos of theta (Opt) 
       osg::Vec2d* const scPsi=0)  // OUT: Sin/Cos of psi   (Opt) 

-----------------------------------------------------
Nav Function Usage:
  Basic::Nav::computeRotationalMatrixDeg(angles, &rm, &scPhi, &scTht, &scPsi);

-----------------------------------------------------
Test Inputs: 
  angles[0] = 10.0000  [DEG]
  angles[1] = 20.0000  [DEG]
  angles[2] = 30.0000  [DEG]

Expected Results: 
  testRotMatrix = 
      0.8138      0.4698     -0.3420
     -0.4410      0.8826      0.1632
      0.3785      0.0180      0.9254

  scPhi[0]  =       0.1736
  scPhi[1]  =       0.9848
  scTht[0]  =       0.3420
  scTht[1]  =       0.9397
  scPsi[0]  =       0.5000
  scPsi[1]  =       0.8660

Actual Results: 
  rm = 
      0.8138      0.4698     -0.3420
     -0.4410      0.8826      0.1632
      0.3785      0.0180      0.9254

  scPhi[0]  =       0.1736
  scPhi[1]  =       0.9848
  scTht[0]  =       0.3420
  scTht[1]  =       0.9397
  scPsi[0]  =       0.5000
  scPsi[1]  =       0.8660

Errors: 
  rm error = 
     -0.0000      0.0000     -0.0000
      0.0000     -0.0000     -0.0000
      0.0000      0.0000      0.0000

  scPhi[0] error =       0.0000
  scPhi[1] error =       0.0000
  scTht[0] error =       0.0000
  scTht[1] error =       0.0000
  scPsi[0] error =       0.0000
  scPsi[1] error =       0.0000

=============================================
test23_convertPosVec2llE

-----------------------------------------------------
Nav Function Prototype:
  bool convertPosVec2llE( 
       const double slat,      // IN: source latitude     [DEG] 
       const double slon,      // IN: source longitude    [DEG] 
       const osg::Vec3d& pos,  // IN: NED position vector   [M] 
       double* const lat,      // OUT: Latitude           [DEG] 
       double* const lon,      // OUT: Longitude          [DEG] 
       double* const alt)      // OUT: Altitude             [M] 

-----------------------------------------------------
Nav Function Usage:
  Basic::Nav::convertPosVec2llE(rlat, rlon, pos, &lat, &lon, &alt);

-----------------------------------------------------
Test Inputs:        
  rlat = 40;   [DEG]
  rlon = 50;   [DEG]
  x    = 1000    [M]
  y    = 2000    [M]
  z    = 3000    [M]

Expected Results: 
  lat =      40.0090  [DEG]
  lon =      50.0234  [DEG]
  alt =   -3000.0000    [M]

Actual Results: 
  lat =      40.0090  [DEG]
  lon =      50.0234  [DEG]
  alt =   -3000.0000    [M]

Errors: 
  lat error =       0.0000
  lon error =       0.0000
  alt error =       0.0000

=============================================
test24_convertLL2PosVecE

-----------------------------------------------------
Nav Function Prototype:
  bool convertLL2PosVecE( 
       const double rlat,      // IN: Reference latitude   [DEG]   
       const double rlon,      // IN: Reference longitude  [DEG]   
       const double tlat,      // IN: Target latitude      [DEG]   
       const double tlon,      // IN: Target longitude     [DEG]   
       const double talt,      // IN: Target altitude      [M]     
       osg::Vec3d* const pos)  // OUT: NED position vector [M,M,M] 

-----------------------------------------------------
Nav Function Usage:
  Basic::Nav::convertLL2PosVecE(rlat, rlon, tlat, tlon, talt, &pos);

-----------------------------------------------------
Test Inputs: 
  rlat =      40.0000  [DEG]
  rlon =      50.0000  [DEG]

  tlat =      41.0000  [M]
  tlon =      51.0000  [M]
  talt =    5000.0000  [M]

Expected Results: 
  pos[0] =  111034.6326 [M]  north
  pos[1] =   85393.8570 [M]  east 
  pos[2] =   -5000.0000 [M]  down 

Actual Results: 
  pos[0] =  111034.6326 [M]  north
  pos[1] =   85393.8570 [M]  east 
  pos[2] =   -5000.0000 [M]  down 

Errors: 
  pos[0] error =      -0.0000
  pos[1] error =      -0.0000
  pos[2] error =       0.0000

=====================================================
test25_convertEcef2Geod

-----------------------------------------------------                       
Nav Function Prototype: Convert ECEF (XYZ) to Geodetic (LLA)                
-----------------------------------------------------                       
  Using type double single variables                                        
    bool convertEcef2Geod(                                                  
         const double x,                // IN:  ECEF X component    [M]     
         const double y,                // IN:  ECEF Y component    [M]     
         const double z,                // IN:  ECEF Z component    [M]     
         double* const plat,            // OUT: Geodetic latitude   [DEG]   
         double* const plon,            // OUT: Geodetic longitude  [DEG]   
         double* const palt,            // OUT: Geodetic altitude   [DEG]   
         const EarthModel* const em=0); // IN:  Pointer to an optional      
                                                earth model (dflt: WGS-84)  
                                                                            
  Using osg::Vec3d vectors                                                  
    bool convertEcef2Geod(                                                  
         const osg::Vec3d& xyz,         // IN:  ECEF [IX IY IZ]             
         osg::Vec3d* const plla,        // OUT: Geodetic [ILAT ILON IALT]   
         const EarthModel* const em=0); // IN:  Pointer to an optional      
                                                earth model (dflt: WGS-84)  
                                                                            
  Using array vectors                                                       
    bool convertEcef2Geod(                                                  
         const double xyz[3],           // IN:  ECEF [IX IY IZ]             
         double lla[3],                 // OUT: Geodetic [ILAT ILON IALT]   
         const EarthModel* const em=0); // IN:  Pointer to an optional      
                                                earth model (dflt: WGS-84)  

-----------------------------------------------------
Nav Function Usage:
  Basic::Nav::convertEcef2Geod(x, y, z, &lat, &lon, &alt, pEM); 
  Basic::Nav::convertEcef2Geod(xyz, &lla, pEM);                 
  Basic::Nav::convertEcef2Geod(xyz, lla, pEM);                  

-----------------------------------------------------
Test Inputs: 
  x = xyz[0] = XYZ[0] = 4000000.0000  // [M]
  y = xyz[1] = XYZ[1] = 4000000.0000  // [M]
  z = xyz[2] = XYZ[2] = 4000000.0000  // [M]

-----------------------------------------------------
Expected Results: 
  lat = lla[0] = LLA[0] =      35.4314  // [DEG]
  lon = lla[0] = LLA[0] =      45.0000  // [DEG]
  alt = lla[0] = LLA[0] =  557215.8470  // [M]  

-----------------------------------------------------
Actual Results: 
  lat    =      35.4314
  lon    =      45.0000
  alt    =  557215.8470

  lla[0] =      35.4314
  lla[1] =      45.0000
  lla[2] =  557215.8470

  LLA[0] =      35.4314
  LLA[1] =      45.0000
  LLA[2] =  557215.8470

-----------------------------------------------------
Errors: 
  lat    error =      -0.0000
  lon    error =       0.0000
  alt    error =      -0.0000

  lla[0] error =      -0.0000
  lla[1] error =       0.0000
  lla[2] error =      -0.0000

  LLA[0] error =      -0.0000
  LLA[1] error =       0.0000
  LLA[2] error =      -0.0000

-----------------------------------------------------
Nav Function Prototypes:

  // Form 1: Using type double variables
  bool convertGeod2Ecef(
       const double lat,       // IN: Geodetic latitude   [DEG]
       const double lon,       // IN: Geodetic longitude  [DEG]
       const double alt,       // IN: Geodetic altitude   [M]
       double* const pX,       // OUT: ECEF X component   [M]
       double* const pY,       // OUT: ECEF Y component   [M]
       double* const pZ,       // OUT: ECEF Z component   [M]
       const EarthModel* const em=0); // IN: Pointer to an optional earth model (default: WGS-84)

  // Form 2: Using osg::Vec3d vectors
  bool convertGeod2Ecef(
       const osg::Vec3d& lla,  // IN: Geodetic [ ILAT ILON IALT ]
       osg::Vec3d* const ecef, // OUT: ECEF [ IX IY IZ ]
       const EarthModel* const em=0); // IN: Pointer to an optional earth model (default: WGS-84)

  // Form 3: Using array vectors
  bool convertGeod2Ecef(
       const double lla[3],    // IN: Geodetic [ ILAT ILON IALT ]
       double ecef[3],         // OUT: ECEF [ IX IY IZ ]
       const EarthModel* const em=0); // IN: Pointer to an optional earth model (default: WGS-84)

-----------------------------------------------------
Nav Function Usage:
=============================================
test26_convertGeod2Ecef

Test inputs:
  lat =      40.0000;  // [DEG]
  lon =      50.0000;  // [DEG]
  alt =       0.0000;  // [M]  

Expected Results: 
  x   = 3144971.8231  // [M]
  y   = 3748031.4688  // [M]
  z   = 4077985.5722  // [M]

----------------------------------------------------------------------
Form 1:
Basic::Nav::convertGeod2Ecef(lat, lon, alt, &x, &y, &z, pEM);

Results:
  x      = 3144971.8231; err =   0.0000
  y      = 3748031.4688; err =   0.0000
  z      = 4077985.5722; err =   0.0000

----------------------------------------------------------------------
Form 2:
Basic::Nav::convertGeod2Ecef(lla, &xyz, pEM);

Results:
  xyz[0] = 3144971.8231; err =   0.0000
  xyz[1] = 3748031.4688; err =   0.0000
  xyz[2] = 4077985.5722; err =   0.0000

----------------------------------------------------------------------
Form 3:

Basic::Nav::convertGeod2Ecef(LLA, XYZ, pEM);

Results:
  XYZ[0] = 3144971.8231; err =   0.0000
  XYZ[1] = 3748031.4688; err =   0.0000
  XYZ[2] = 4077985.5722; err =   0.0000

==============================================
lat       =       -80.0000
lon       =        10.0000

latZone   =              C
lonZone   =             32
N         =   1118247.5851
E         =    519384.8033

latitude  =       -80.0000
longitude =        10.0000

latitude  error =         0.0000
longitude error =        -0.0000
==============================================
lat       =       -70.0000
lon       =        20.0000

latZone   =              D
lonZone   =             34
N         =   2233813.8486
E         =    461830.2177

latitude  =       -70.0002
longitude =        20.0000

latitude  error =        -0.0002
longitude error =        -0.0000
==============================================
lat       =       -60.0000
lon       =        30.0000

latZone   =              E
lonZone   =             36
N         =   3344794.5164
E         =    332705.1789

latitude  =       -60.0003
longitude =        30.0000

latitude  error =        -0.0003
longitude error =        -0.0000
==============================================
lat       =       -50.0000
lon       =        40.0000

latZone   =              F
lonZone   =             37
N         =   4460890.1847
E         =    571666.4475

latitude  =       -50.0003
longitude =        40.0000

latitude  error =        -0.0003
longitude error =         0.0000
==============================================
lat       =       -40.0000
lon       =        50.0000

latZone   =              H
lonZone   =             39
N         =   5571763.9353
E         =    414639.5382

latitude  =       -40.0001
longitude =        50.0000

latitude  error =        -0.0001
longitude error =        -0.0000
==============================================
lat       =       -30.0000
lon       =        60.0000

latZone   =              J
lonZone   =             41
N         =   6677424.0956
E         =    210590.3467

latitude  =       -29.9999
longitude =        60.0000

latitude  error =         0.0001
longitude error =         0.0000
==============================================
lat       =       -20.0000
lon       =        70.0000

latZone   =              K
lonZone   =             42
N         =   7788206.4438
E         =    604609.3238

latitude  =       -19.9998
longitude =        70.0000

latitude  error =         0.0002
longitude error =        -0.0000
==============================================
lat       =       -10.0000
lon       =        80.0000

latZone   =              L
lonZone   =             44
N         =   8894421.4109
E         =    390399.2275

latitude  =        -9.9997
longitude =        80.0000

latitude  error =         0.0003
longitude error =         0.0000
==============================================
lat       =         0.0000
lon       =        90.0000

latZone   =              N
lonZone   =             46
N         =         0.0000
E         =    166021.4432

latitude  =         0.0002
longitude =        90.0000

latitude  error =         0.0002
longitude error =         0.0000
==============================================
lat       =        10.0000
lon       =       100.0000

latZone   =              P
lonZone   =             47
N         =   1105578.5892
E         =    609600.7725

latitude  =        10.0000
longitude =       100.0000

latitude  error =         0.0000
longitude error =         0.0000
==============================================
lat       =        20.0000
lon       =       110.0000

latZone   =              Q
lonZone   =             49
N         =   2211793.5561
E         =    395390.6762

latitude  =        19.9998
longitude =       110.0000

latitude  error =        -0.0002
longitude error =         0.0000
==============================================
lat       =        30.0000
lon       =       120.0000

latZone   =              R
lonZone   =             51
N         =   3322575.9044
E         =    210590.3467

latitude  =        29.9997
longitude =       120.0000

latitude  error =        -0.0003
longitude error =         0.0000
==============================================
lat       =        40.0000
lon       =       130.0000

latZone   =              T
lonZone   =             52
N         =   4428236.0646
E         =    585360.4618

latitude  =        39.9997
longitude =       130.0000

latitude  error =        -0.0003
longitude error =        -0.0000
==============================================
lat       =        50.0000
lon       =       140.0000

latZone   =              U
lonZone   =             54
N         =   5539109.8153
E         =    428333.5525

latitude  =        49.9999
longitude =       140.0000

latitude  error =        -0.0001
longitude error =         0.0000
==============================================
lat       =        60.0000
lon       =       150.0000

latZone   =              V
lonZone   =             56
N         =   6655205.4836
E         =    332705.1789

latitude  =        60.0001
longitude =       150.0000

latitude  error =         0.0001
longitude error =        -0.0000
==============================================
lat       =        70.0000
lon       =       160.0000

latZone   =              W
lonZone   =             57
N         =   7766186.1515
E         =    538169.7823

latitude  =        70.0002
longitude =       160.0000

latitude  error =         0.0002
longitude error =         0.0000
==============================================
lat       =        80.0000
lon       =       170.0000

latZone   =              X
lonZone   =             59
N         =   8881752.4148
E         =    480615.1967

latitude  =        80.0003
longitude =       170.0000

latitude  error =         0.0003
longitude error =        -0.0000
==============================================
lat       =         0.0000
lon       =       180.0000

latZone   =              N
lonZone   =             61
N         =         0.0000
E         =    166021.4432

latitude  =         0.0002
longitude =       180.0000

latitude  error =         0.0002
longitude error =         0.0000
==============================================
lat       =       -80.0000
lon       =       -10.0000

latZone   =              C
lonZone   =             29
N         =   1118247.5851
E         =    480615.1967

latitude  =       -80.0000
longitude =       -10.0000

latitude  error =         0.0000
longitude error =         0.0000
==============================================
lat       =       -70.0000
lon       =       -20.0000

latZone   =              D
lonZone   =             27
N         =   2233813.8486
E         =    538169.7823

latitude  =       -70.0002
longitude =       -20.0000

latitude  error =        -0.0002
longitude error =         0.0000
==============================================
lat       =       -60.0000
lon       =       -30.0000

latZone   =              E
lonZone   =             26
N         =   3344794.5164
E         =    332705.1789

latitude  =       -60.0003
longitude =       -30.0000

latitude  error =        -0.0003
longitude error =        -0.0000
==============================================
lat       =       -50.0000
lon       =       -40.0000

latZone   =              F
lonZone   =             24
N         =   4460890.1847
E         =    428333.5525

latitude  =       -50.0003
longitude =       -40.0000

latitude  error =        -0.0003
longitude error =        -0.0000
==============================================
lat       =       -40.0000
lon       =       -50.0000

latZone   =              H
lonZone   =             22
N         =   5571763.9353
E         =    585360.4618

latitude  =       -40.0001
longitude =       -50.0000

latitude  error =        -0.0001
longitude error =         0.0000
==============================================
lat       =       -30.0000
lon       =       -60.0000

latZone   =              J
lonZone   =             21
N         =   6677424.0956
E         =    210590.3467

latitude  =       -29.9999
longitude =       -60.0000

latitude  error =         0.0001
longitude error =         0.0000
==============================================
lat       =       -20.0000
lon       =       -70.0000

latZone   =              K
lonZone   =             19
N         =   7788206.4438
E         =    395390.6762

latitude  =       -19.9998
longitude =       -70.0000

latitude  error =         0.0002
longitude error =         0.0000
==============================================
lat       =       -10.0000
lon       =       -80.0000

latZone   =              L
lonZone   =             17
N         =   8894421.4109
E         =    609600.7725

latitude  =        -9.9997
longitude =       -80.0000

latitude  error =         0.0003
longitude error =        -0.0000
==============================================
lat       =         0.0000
lon       =       -90.0000

latZone   =              N
lonZone   =             16
N         =         0.0000
E         =    166021.4432

latitude  =         0.0002
longitude =       -90.0000

latitude  error =         0.0002
longitude error =         0.0000
==============================================
lat       =        10.0000
lon       =      -100.0000

latZone   =              P
lonZone   =             14
N         =   1105578.5892
E         =    390399.2275

latitude  =        10.0000
longitude =      -100.0000

latitude  error =         0.0000
longitude error =        -0.0000
==============================================
lat       =        20.0000
lon       =      -110.0000

latZone   =              Q
lonZone   =             12
N         =   2211793.5561
E         =    604609.3238

latitude  =        19.9998
longitude =      -110.0000

latitude  error =        -0.0002
longitude error =        -0.0000
==============================================
lat       =        30.0000
lon       =      -120.0000

latZone   =              R
lonZone   =             11
N         =   3322575.9044
E         =    210590.3467

latitude  =        29.9997
longitude =      -120.0000

latitude  error =        -0.0003
longitude error =         0.0000
==============================================
lat       =        40.0000
lon       =      -130.0000

latZone   =              T
lonZone   =              9
N         =   4428236.0646
E         =    414639.5382

latitude  =        39.9997
longitude =      -130.0000

latitude  error =        -0.0003
longitude error =         0.0000
==============================================
lat       =        50.0000
lon       =      -140.0000

latZone   =              U
lonZone   =              7
N         =   5539109.8153
E         =    571666.4475

latitude  =        49.9999
longitude =      -140.0000

latitude  error =        -0.0001
longitude error =        -0.0000
==============================================
lat       =        60.0000
lon       =      -150.0000

latZone   =              V
lonZone   =              6
N         =   6655205.4836
E         =    332705.1789

latitude  =        60.0001
longitude =      -150.0000

latitude  error =         0.0001
longitude error =        -0.0000
==============================================
lat       =        70.0000
lon       =      -160.0000

latZone   =              W
lonZone   =              4
N         =   7766186.1515
E         =    461830.2177

latitude  =        70.0002
longitude =      -160.0000

latitude  error =         0.0002
longitude error =        -0.0000
==============================================
lat       =        80.0000
lon       =      -170.0000

latZone   =              X
lonZone   =              2
N         =   8881752.4148
E         =    519384.8033

latitude  =        80.0003
longitude =      -170.0000

latitude  error =         0.0003
longitude error =         0.0000
==============================================
lat       =         0.0000
lon       =      -180.0000

latZone   =              N
lonZone   =              1
N         =         0.0000
E         =    166021.4432

latitude  =         0.0002
longitude =      -180.0000

latitude  error =         0.0002
longitude error =         0.0000
==============================================
lat       =         0.0000
lon       =         0.0000

latZone   =              N
lonZone   =             31
N         =         0.0000
E         =    166021.4432

latitude  =         0.0002
longitude =         0.0000

latitude  error =         0.0002
longitude error =         0.0000
==============================================
lat       =         0.0000
lon       =         0.0000

latZone   =              N
lonZone   =             31
N         =         0.0000
E         =    166021.4432

latitude  =         0.0002
longitude =         0.0000

latitude  error =         0.0002
longitude error =         0.0000
